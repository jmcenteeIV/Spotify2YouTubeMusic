"""
This type stub file was generated by pyright.
"""

from six.moves.BaseHTTPServer import BaseHTTPRequestHandler

__all__ = ["SpotifyClientCredentials", "SpotifyOAuth", "SpotifyOauthError", "SpotifyStateError", "SpotifyImplicitGrant", "SpotifyPKCE"]
logger = ...
class SpotifyOauthError(Exception):
    """ Error during Auth Code or Implicit Grant flow """
    def __init__(self, message, error=..., error_description=..., *args, **kwargs) -> None:
        ...
    


class SpotifyStateError(SpotifyOauthError):
    """ The state sent and state recieved were different """
    def __init__(self, local_state=..., remote_state=..., message=..., error=..., error_description=..., *args, **kwargs) -> None:
        ...
    


class SpotifyAuthBase:
    def __init__(self, requests_session) -> None:
        ...
    
    @property
    def client_id(self): # -> str:
        ...
    
    @client_id.setter
    def client_id(self, val): # -> None:
        ...
    
    @property
    def client_secret(self): # -> str:
        ...
    
    @client_secret.setter
    def client_secret(self, val): # -> None:
        ...
    
    @property
    def redirect_uri(self): # -> str:
        ...
    
    @redirect_uri.setter
    def redirect_uri(self, val): # -> None:
        ...
    
    @staticmethod
    def is_token_expired(token_info):
        ...
    
    def __del__(self): # -> None:
        """Make sure the connection (pool) gets closed"""
        ...
    


class SpotifyClientCredentials(SpotifyAuthBase):
    OAUTH_TOKEN_URL = ...
    def __init__(self, client_id=..., client_secret=..., proxies=..., requests_session=..., requests_timeout=..., cache_handler=...) -> None:
        """
        Creates a Client Credentials Flow Manager.

        The Client Credentials flow is used in server-to-server authentication.
        Only endpoints that do not access user information can be accessed.
        This means that endpoints that require authorization scopes cannot be accessed.
        The advantage, however, of this authorization flow is that it does not require any
        user interaction

        You can either provide a client_id and client_secret to the
        constructor or set SPOTIPY_CLIENT_ID and SPOTIPY_CLIENT_SECRET
        environment variables

        Parameters:
             * client_id: Must be supplied or set as environment variable
             * client_secret: Must be supplied or set as environment variable
             * proxies: Optional, proxy for the requests library to route through
             * requests_session: A Requests session
             * requests_timeout: Optional, tell Requests to stop waiting for a response after
                                 a given number of seconds
             * cache_handler: An instance of the `CacheHandler` class to handle
                              getting and saving cached authorization tokens.
                              Optional, will otherwise use `CacheFileHandler`.
                              (takes precedence over `cache_path` and `username`)

        """
        ...
    
    def get_access_token(self, as_dict=..., check_cache=...): # -> Any:
        """
        If a valid access token is in memory, returns it
        Else feches a new token and returns it

            Parameters:
            - as_dict - a boolean indicating if returning the access token
                as a token_info dictionary, otherwise it will be returned
                as a string.
        """
        ...
    


class SpotifyOAuth(SpotifyAuthBase):
    """
    Implements Authorization Code Flow for Spotify's OAuth implementation.
    """
    OAUTH_AUTHORIZE_URL = ...
    OAUTH_TOKEN_URL = ...
    def __init__(self, client_id=..., client_secret=..., redirect_uri=..., state=..., scope=..., cache_path=..., username=..., proxies=..., show_dialog=..., requests_session=..., requests_timeout=..., open_browser=..., cache_handler=...) -> None:
        """
        Creates a SpotifyOAuth object

        Parameters:
             * client_id: Must be supplied or set as environment variable
             * client_secret: Must be supplied or set as environment variable
             * redirect_uri: Must be supplied or set as environment variable
             * state: Optional, no verification is performed
             * scope: Optional, either a list of scopes or comma separated string of scopes.
                      e.g, "playlist-read-private,playlist-read-collaborative"
             * cache_path: (deprecated) Optional, will otherwise be generated
                           (takes precedence over `username`)
             * username: (deprecated) Optional or set as environment variable
                         (will set `cache_path` to `.cache-{username}`)
             * proxies: Optional, proxy for the requests library to route through
             * show_dialog: Optional, interpreted as boolean
             * requests_session: A Requests session
             * requests_timeout: Optional, tell Requests to stop waiting for a response after
                                 a given number of seconds
             * open_browser: Optional, whether or not the web browser should be opened to
                             authorize a user
             * cache_handler: An instance of the `CacheHandler` class to handle
                              getting and saving cached authorization tokens.
                              Optional, will otherwise use `CacheFileHandler`.
                              (takes precedence over `cache_path` and `username`)
        """
        ...
    
    def validate_token(self, token_info): # -> None:
        ...
    
    def get_authorize_url(self, state=...): # -> str:
        """ Gets the URL to use to authorize this app
        """
        ...
    
    def parse_response_code(self, url): # -> str:
        """ Parse the response code in the given response url

            Parameters:
                - url - the response url
        """
        ...
    
    @staticmethod
    def parse_auth_response_url(url): # -> tuple[str | None, ...]:
        ...
    
    def get_auth_response(self, open_browser=...): # -> str | None:
        ...
    
    def get_authorization_code(self, response=...): # -> str | None:
        ...
    
    def get_access_token(self, code=..., as_dict=..., check_cache=...):
        """ Gets the access token for the app given the code

            Parameters:
                - code - the response code
                - as_dict - a boolean indicating if returning the access token
                            as a token_info dictionary, otherwise it will be returned
                            as a string.
        """
        ...
    
    def refresh_access_token(self, refresh_token):
        ...
    
    def get_cached_token(self): # -> Any | None:
        ...
    


class SpotifyPKCE(SpotifyAuthBase):
    """ Implements PKCE Authorization Flow for client apps

    This auth manager enables *user and non-user* endpoints with only
    a client secret, redirect uri, and username. When the app requests
    an an access token for the first time, the user is prompted to
    authorize the new client app. After authorizing the app, the client
    app is then given both access and refresh tokens. This is the
    preferred way of authorizing a mobile/desktop client.

    """
    OAUTH_AUTHORIZE_URL = ...
    OAUTH_TOKEN_URL = ...
    def __init__(self, client_id=..., redirect_uri=..., state=..., scope=..., cache_path=..., username=..., proxies=..., requests_timeout=..., requests_session=..., open_browser=..., cache_handler=...) -> None:
        """
        Creates Auth Manager with the PKCE Auth flow.

        Parameters:
             * client_id: Must be supplied or set as environment variable
             * redirect_uri: Must be supplied or set as environment variable
             * state: Optional, no verification is performed
             * scope: Optional, either a list of scopes or comma separated string of scopes.
                      e.g, "playlist-read-private,playlist-read-collaborative"
             * cache_path: (deprecated) Optional, will otherwise be generated
                           (takes precedence over `username`)
             * username: (deprecated) Optional or set as environment variable
                         (will set `cache_path` to `.cache-{username}`)
             * proxies: Optional, proxy for the requests library to route through
             * requests_timeout: Optional, tell Requests to stop waiting for a response after
                                 a given number of seconds
             * requests_session: A Requests session
             * open_browser: Optional, thether or not the web browser should be opened to
                             authorize a user
             * cache_handler: An instance of the `CacheHandler` class to handle
                              getting and saving cached authorization tokens.
                              Optional, will otherwise use `CacheFileHandler`.
                              (takes precedence over `cache_path` and `username`)
        """
        ...
    
    def get_authorize_url(self, state=...): # -> str:
        """ Gets the URL to use to authorize this app """
        ...
    
    def get_authorization_code(self, response=...): # -> str | None:
        ...
    
    def validate_token(self, token_info): # -> None:
        ...
    
    def get_pkce_handshake_parameters(self): # -> None:
        ...
    
    def get_access_token(self, code=..., check_cache=...):
        """ Gets the access token for the app

            If the code is not given and no cached token is used, an
            authentication window will be shown to the user to get a new
            code.

            Parameters:
                - code - the response code from authentication
                - check_cache - if true, checks for a locally stored token
                                before requesting a new token
        """
        ...
    
    def refresh_access_token(self, refresh_token):
        ...
    
    def parse_response_code(self, url): # -> str:
        """ Parse the response code in the given response url

            Parameters:
                - url - the response url
        """
        ...
    
    @staticmethod
    def parse_auth_response_url(url): # -> tuple[str | None, ...]:
        ...
    
    def get_cached_token(self): # -> Any | None:
        ...
    


class SpotifyImplicitGrant(SpotifyAuthBase):
    """ Implements Implicit Grant Flow for client apps

    This auth manager enables *user and non-user* endpoints with only
    a client secret, redirect uri, and username. The user will need to
    copy and paste a URI from the browser every hour.

    Security Warning
    -----------------
    The OAuth standard no longer recommends the Implicit Grant Flow for
    client-side code. Spotify has implemented the OAuth-suggested PKCE
    extension that removes the need for a client secret in the
    Authentication Code flow. Use the SpotifyPKCE auth manager instead
    of SpotifyImplicitGrant.

    SpotifyPKCE contains all of the functionality of
    SpotifyImplicitGrant, plus automatic response retrieval and
    refreshable tokens. Only a few replacements need to be made:

    * get_auth_response()['access_token'] ->
      get_access_token(get_authorization_code())
    * get_auth_response() ->
      get_access_token(get_authorization_code()); get_cached_token()
    * parse_response_token(url)['access_token'] ->
      get_access_token(parse_response_code(url))
    * parse_response_token(url) ->
      get_access_token(parse_response_code(url)); get_cached_token()

    The security concern in the Implict Grant flow is that the token is
    returned in the URL and can be intercepted through the browser. A
    request with an authorization code and proof of origin could not be
    easily intercepted without a compromised network.
    """
    OAUTH_AUTHORIZE_URL = ...
    def __init__(self, client_id=..., redirect_uri=..., state=..., scope=..., cache_path=..., username=..., show_dialog=..., cache_handler=...) -> None:
        """ Creates Auth Manager using the Implicit Grant flow

        **See help(SpotifyImplictGrant) for full Security Warning**

        Parameters
        ----------
        * client_id: Must be supplied or set as environment variable
        * redirect_uri: Must be supplied or set as environment variable
        * state: May be supplied, no verification is performed
        * scope: Optional, either a list of scopes or comma separated string of scopes.
                 e.g, "playlist-read-private,playlist-read-collaborative"
        * cache_handler: An instance of the `CacheHandler` class to handle
                              getting and saving cached authorization tokens.
                              May be supplied, will otherwise use `CacheFileHandler`.
                              (takes precedence over `cache_path` and `username`)
        * cache_path: (deprecated) May be supplied, will otherwise be generated
                      (takes precedence over `username`)
        * username: (deprecated) May be supplied or set as environment variable
                    (will set `cache_path` to `.cache-{username}`)
        * show_dialog: Interpreted as boolean
        """
        ...
    
    def validate_token(self, token_info): # -> None:
        ...
    
    def get_access_token(self, state=..., response=..., check_cache=...): # -> Any | str | None:
        """ Gets Auth Token from cache (preferred) or user interaction

        Parameters
        ----------
        * state: May be given, overrides (without changing) self.state
        * response: URI with token, can break expiration checks
        * check_cache: Interpreted as boolean
        """
        ...
    
    def get_authorize_url(self, state=...): # -> str:
        """ Gets the URL to use to authorize this app """
        ...
    
    def parse_response_token(self, url, state=...): # -> dict[str, str | Unknown | None]:
        """ Parse the response code in the given response url """
        ...
    
    @staticmethod
    def parse_auth_response_url(url): # -> tuple[str | None, ...]:
        ...
    
    def get_auth_response(self, state=...): # -> dict[str, str | Unknown | None]:
        """ Gets a new auth **token** with user interaction """
        ...
    
    def get_cached_token(self): # -> Any | None:
        ...
    


class RequestHandler(BaseHTTPRequestHandler):
    def do_GET(self): # -> None:
        ...
    
    def log_message(self, format, *args): # -> None:
        ...
    


def start_local_http_server(port, handler=...): # -> HTTPServer:
    ...

